<!-- 本书的定位是短篇，科普向，外加一点点专业知识。 -->
<!-- Linux Shell 第一章的整理 -->
一般来说，Linux是对以Linux为内核的操作系统的统称，与Windows操作系统和MacOS操作系统属并列关系。  
Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。
Linux从最上层到最底层可以划分为如下五个部分：
- 应用软件(微信，qq等)
- 图形化桌面环境(Desktop Environment)
- GNU工具集(你可能听说过ls 等命令)
- Linux内核
- 计算机硬件

首先简述一下Linux内核所负责的四部分职责。

- 系统内存管理
- 系统软件进程管理
- 硬件设备管理
- 文件系统管理

## 系统内存管理
除了真实的物理内存(内存条)，Linux还存在一个交换空间(swap space)的概念。交换空间是在你的硬盘设备上提前分配好的一块区域。假如运行Dota2需要4G的内存空间，但是你的内存条只有2G,不够运行Dota2.那么此时如果你有已经分配好的交换空间，就可以使用2G交换空间 + 2G物理内存的方式运行Dota2.真实的物理内存和交换空间两部分加在一起统称为`虚拟内存`，Linux内核即提供对虚拟内存的管理。  

虚拟内存会按组划分为很多块，这些块的术语称为页面(page)。内核会维护一个内存页面表，用来指明各个页面的存放位置，哪些在物理内存中，哪些在交换空间中。  

Linux内核会记录哪些页面正在使用，并且会把一段时间内未访问的，在物理内存中的页面移动到交换空间里，这个过程称为换出(swapping out)，即使此时物理内存仍有空余，换出的过程也会进行。当程序需要访问一个已经被换出到交换空间的页面时，则内核需要将这个页面换入到物理内存中。如果此时物理内存均已用满，没有空闲的空间，则内核必须选择一个已有的页面进行换出，为需要换入的新页面腾挪位置。显然换入/换出的过程会耗费时间，拖慢程序的运行速度，但是在物理内存不足时，使用交换空间至少可以保证程序可以运行。  

在2020年，绝大多数个人主机内存均已很充足，网络上也有个人主机再无需设置交换空间的声音。但是还是建议在使用Linux时，要设置交换空间。一是因为有一些程序如果没有交换空间可能无法正确运行，二是因为个人主机需要交换空间的存在才可以支持休眠等功能。

## 系统软件进程管理

Linux中运行的程序一般称为进程。内核对进程采取相应的管理和控制。为了尽可能充分地压榨 CPU 性能，内核使用调度器，通过一定的优先级算法将 CPU 按照时间动态的分配给各个进程。让我们感觉就像所有进程都在同时使用 CPU 一样。内核在启动任何新的进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。


## 文件系统管理  

不同于其他一些操作系统，Linux内核支持通过不同类型的文件系统从硬盘中读写数据。除了自有的诸多文件系统外，Linux还支持从其他操作系统（比如Microsoft  Windows）采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持。目前较常用的文件系统为ext4,btrfs,XFS,msdos(FAT16),vfat(FAT32)以及ntfs。  

Linux服务器所访问的所有硬盘都必须格式化成文件系统类型中的一种。Linux内核采用虚拟文件系统（Virtual File System，VFS）作为和每个文件系统交互的接口。这为Linux内核同任何类型文件系统通信提供了一个标准接口。当每个文件系统都被挂载和使用时，VFS将信息都缓存在内存中。


## 硬件设备管理

内核的另一职责是管理硬件设备。任何Linux系统需要与之通信的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交换数据。在Linux内核中有两种方法用于插入设备驱动代码：

- 编译进内核的设备驱动代码
- 可插入内核的设备驱动模块

以前，插入设备驱动代码的唯一途径是重新编译内核。每次给系统添加新设备，都要重新编译一遍内核代码。随着Linux内核支持的硬件设备越来越多，这个过程变得越来越低效。不过好在Linux开发人员设计出了一种更好的将驱动代码插入运行中的内核的方法。开发人员提出了内核模块的概念。它允许将驱动代码插入到运行中的内核而无需重新编译内核。同时，当设备不再使用时也可将内核模块从内核中移走。这种方式极大地简化和扩展了硬件设备在Linux上的使用。

Linux系统将硬件设备当成特殊的文件，称为设备文件。设备文件有3种分类：
- 字符型设备文件
- 块设备文件
- 网络设备文件  
字符型设备文件是指处理数据时每次只能处理一个字符的设备。大多数类型的老式调制解调器和终端都是作为字符型设备文件创建的。  
块设备文件是指处理数据时每次能处理大块数据的设备，比如硬盘。  
网络设备文件是指采用数据包发送和接收数据的设备，包括各种网卡和一个特殊的回环设备。这个回环设备允许Linux系统使用常见的网络编程协议同自身通信。Linux为系统上的每个设备都创建一种称为节点的特殊文件。与设备的所有通信都通过设备节点完成。每个节点都有唯一的数值对供Linux内核标识它。数值对包括一个主设备号和一个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特定设备。  

## GNU 工具组

Linux内核主要提供了上述四个方面的管理职能，但是其并没有提供一套系统工具来控制、操作文件和程序。GNU组织开发了一套完整的Unix工具来填补了这部分的空白。将Linus的Linux内核和GNU操作系统工具整合起来，就产生了一款完整的、功能丰富的免费操作系统。  

尽管通常将Linux内核和GNU工具的结合体称为Linux，但你也会在互联网上看到一些Linux纯粹主义者将其称为GNU/Linux系统，藉此向GNU组织所作的贡献致意。    

你可以在这个页面查看所有[GNU软件包列表](https://www.gnu.org/software/software.html)

1. 核心GNU工具组以及常用工具包  
GNU项目的主旨在于为Unix系统管理员设计出一套类似于Unix的环境。这个目标促使该项目移植了很多常见的Unix系统命令行工具。供Linux系统使用的这组核心工具被称为coreutils[core utilities](https://wiki.archlinux.org/index.php/Core_utilities)软件包。

<!-- GNU coreutils软件包由三部分构成：OUTDATE
- 用以处理文件的工具(ls,rm)
- 用以操作文本流的工具(grep,sed,awk)
- 用以管理系统进程的工具 -->

coreutils包含对Linux系统管理员和程序员至关重要的工具。本书将详细介绍GNU coreutils软件包中包含的所有工具。

注意 原有一些包如grep等，在arch下已经拆分出单独的包。  
另有一部分`不属于GNU`的杂项工具存在于[util-linux](https://www.archlinux.org/packages/core/x86_64/util-linux/)


2. shell  
GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。shell包含了一组内部命令，用这些命令可以完成诸如复制文件、移动文件、重命名文件、显示和终止系统中正运行的程序等操作。shell也允许你在命令行提示符中输入程序的名称，它会将程序名传递给内核以启动它。你也可以将多个shell命令放入文件中作为程序执行。这些文件被称作shell脚本。你在命令行上执行的任何命令都可放进一个shell脚本中作为一组命令执行。这为创建那种需要把几个命令放在一起来工作的工具提供了便利。  
在Linux系统上，通常有好几种Linux shell可供选择。不同的shell有不同的特性，有些更利于创建脚本，有些则更利于管理进程。所有Linux发行版默认的shell都是bash  shell。bash  shell由GNU项目开发，被当作标准Unix shell——Bourne shell（以创建者的名字命名）的替代品。bash shell的名称就是针对Bourne shell的拼写所玩的一个文字游戏，称为Bourne again shell。  

除了bash shell，许多Linux使用者喜欢功能更多的[zsh](https://wiki.archlinux.org/index.php/Zsh)作为他们的默认shell。苹果公司也在macOS Catalina 版本之后将默认的shell更改为zsh。


## 图形化桌面环境(Desktop Environment)

如果你安装过Arch Linux，那么你应该知道，系统初步安装完毕后，只提供一个黑白的终端交互界面，用户可以在终端里输入命令，查看结果。如果想进一步拥有一个和Windows一样的图形化界面，就需要安装额外的一些软件包。需要有程序提供从显卡到显示器的互通。即直接和PC上的显卡及显示器打交道的底层程序。它控制着Linux程序如何在电脑上显示窗口和图形。目前的主流实现`方式`有两种，X window协议的第十一版(X11)以及Wayland协议。

### X window协议第十一版(X11)
此协议的具体实现为xorg。Xorg装好之后其实已经提供显示服务器了，即使不安装窗口管理器/DE也能用,有显示服务器就能单个 gui 程序了。但是对比wayland这个包只提供协议，想能用的话必须再另装混成器，或者自带混成器的DE。

Xorg-server是X11的开源实现，其可以产生图形化显示环境，但仅此而已。虽然对于运行独立应用这已经足够，但在日常PC使用中却并不是那么有用。它没有桌面环境供用户操作文件或是开启程序。为此，你还需要一个建立在xorg之上的桌面环境或者窗口管理器。


### wayland
wayland是一个相对于X11的设计来说，是一个新的协议，对于一些X11因为历史原因的设计进行了优化。archlinux上wayland 包只是协议，要用 wayland 还需要实现了 wayland 的显示服务器，通常它也是 wayland 混成器和 wayland 窗口管理器或者桌面环境，wayland 协议下要把这三个分开比较困难。


## 常见的桌面环境(或者窗口管理器)

主流常见DE：KDE，Gnome，DDE

轻量级DE： xfce  fvwm3

窗口管理器：i3  dwm


## Linux 发行版

到此为止，你已经了解了构成完整Linux系统所需要的几个关键部分，那你可能在考虑要怎样才能把它们组成一个Linux系统。幸运的是，已经有人为你做好这些了。我们将完整的Linux系统包称为发行版。有很多不同的Linux发行版来满足可能存在的各种运算需求。大多数发行版是为某个特定用户群定制的，比如商业用户、多媒体爱好者、软件开发人员或者普通家庭用户。每个定制的发行版都包含了支持特定功能所需的各种软件包，比如为多媒体爱好者准备的音频和视频编辑软件，为软件开发人员准备的编译器和集成开发环境（IDE）。

名词`Linux发行版`，可以理解为是和`Windows系统`是同级的概念。其含有内核、一个或多个图形化桌面环境以及预编译好的几乎所有能见到的Linux应用。下面列举一些常见的流行的Linux发行版。

TODO 补充。删除。完善

Slackware 最早的Linux发行版中的一员，在Linux极客中比较流行
Red Hat 主要用于Internet服务器的商业发行版
Fedora 从Red Hat分离出的家用发行版
Gentoo 为高级Linux用户设计的发行版，仅包含Linux源代码
openSUSE 用于商用和家用的发行版
Debian 在Linux专家和商用Linux产品中流行的发行版
ArchLinux



CentOS 一款基于Red Hat企业版Linux源代码构建的免费发行版
Ubuntu 一款用于学校和家庭的免费发行版
PCLinuxOS 一款用于家庭和办公的免费发行版
Mint 一款用于家庭娱乐的免费发行版
Puppy Linux 一款适用于老旧PC的小型免费发行版

## LiveCD
现在的usb livecd改动数据还会消失吗？ 回去确认 忘了 想起来再确认。原来真正的CD 肯定是不可写的。 

缺点是速度慢

不过，有一些Linux LiveCD的改进帮助解决了上述一些问题。这些改进包括：
能将CD上的Linux系统文件复制到内存中；
能将系统文件复制到硬盘上；
能在U盘上存储系统设置；
能在U盘上存储用户设置。


一些Linux LiveCD，如Puppy Linux，只包含最少数量的Linux系统文件。当CD引导启动时，LiveCD的启动脚本直接把它们复制到内存中。  
其他Linux  LiveCD用另外的方法，同样允许你在启动后将CD从光驱中拿走。这种方法是将核心Linux文件作为一个文件复制到Windows硬盘上。
dyne:bolic  Linux  LiveCD采用的就是这种技术，我们称之为`对接`  


Linux发行版就是把Linux系统的各个不同部分汇集起来组成一个易于安装的包。Linux发行版有囊括各种软件的成熟的Linux发行版，也有只包含针对某种特定功能软件包的特定用途发行版。Linux LiveCD则是一种无需将Linux安装到硬盘就能体验Linux的发行版。

---

## TODO linux启动过程(从加电开始的流程)

在「早期用户空间」的最终环节里，真正的根文件系统被挂载好后，就会替换掉原来的伪根文件系统。接着 /sbin/init 被执行，同样也替换掉原来的 /init 进程。

ref:
https://wiki.archlinux.org/index.php/Arch_boot_process_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)

## PID 0/1/2 都是什么
如果运行命令

```bash
ps -ef
```
可以看到PID1为/sbin/init(init)，PID2为kthreadd。PID1和2，是列表中其余全部进程的祖先，这一点可以从PPID(父进程PID)一列看出。  
pid为1的init(/sbin/init) 以及 kthreadd 是在引导时由内核直接创建的，因此它们没有父进程。 在其ppid字段中使用值0表示这一点。 在这里，可以将0视为“内核本身”。

通常，PID1为所有用户进程的祖先，而PID2为所有`内核代码进程`的祖先。Linux中存在一些执行内核代码的进程，但是在调度层面，它们都作为用户进程进行管理，这些进程都是由pid为2的kthreadd创建的。他们的区别也可以通过进程名称一列区分出：全部内核代码进程的名称都被方括号所包裹。

在一些-过时的-教材中，你可能看到pid0有几个常见的名字,swapper/scheduler/idle 。前两个名字都是Unix历史原因，可不理会。实际上大多数Unix已不进行进程swap交换。在linux,swapper不交换任何东西，它仅仅是一个idle进程，可以将其视作linux内核的一部分。pid0进程是运行cpu_idle（）的空闲进程。 它只是无限循环地无所作为。 它的存在使得总是有一个准备好要计划的任务。

在ArchLinux等众多现代Linux发行版中，pid为1的/sbin/init通常为复合型的systemd实现。传统的实现为[SysVinit](https://wiki.archlinux.org/index.php/SysVinit)，在大多数现代Linux发行版中已不再使用。

SysVinit使用一个表来管理在系统开机时要自动启动的进程。在Linux系统上，这个表通常位于专门文件/etc/inittab中。另外一些系统则采用/etc/init.d目录，将开机时启动或停止某个应用的脚本放在这个目录下。这些脚本通过/etc/rcX.d目录下的entry入口启动（这些入口实际上是到/etc/init.d目录中启动脚本的符号链接），这里的X代表运行级（run level）。

SysVinit采用了运行级。运行级决定了init进程运行/etc/inittab文件或/etc/rcX.d目录中定义好的某些特定类型的进程。Linux操作系统有5个启动运行级。运行级为1时，只启动基本的系统进程以及一个控制台终端进程。我们称之为单用户模式。单用户模式通常用来在系统有问题时进行紧急的文件系统维护。显然，在这种模式下，仅有一个人（通常是系统管理员）能登录到系统上操作数据。标准的启动运行级是3。在这个运行级上，大多数应用软件，比如网络支持程序，都会启动。另一个Linux中常见的运行级是5。在这个运行级上系统会启动图形化的X  Window系统，允许用户通过图形化桌面窗口登录系统。Linux系统可以通过调整启动运行级来控制整个系统的功能。通过将运行级从3调整成5，系统就可以从基于控制台的系统变成更先进的图形化X Window系统。


ref:
https://wiki.archlinux.org/index.php/Init
https://zhuanlan.zhihu.com/p/50367649
https://unix.stackexchange.com/questions/13290/init-process-ancestor-of-all-processes
https://superuser.com/questions/377572/what-is-the-main-purpose-of-the-swapper-process-in-unix